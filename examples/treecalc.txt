# Tree calculus application rules (big-step; app normalizes via recursion)
#
# l = leaf
# (b X) = branch containing X
# (f X Y) = fork (application of X to Y)
#
# The four core reduction rules:
#   app(L, z) => B(z)                     -- Rule 1: leaf applied to anything
#   app(B(y), z) => F(y, z)               -- Rule 2: branch creates fork
#   app(F(L, y), z) => y                  -- Rule 3: fork with leaf returns y
#   app(F(F(w, x), y), L) => w            -- Rule 4: nested fork with leaf returns w
#
# Examples from TreeCalcSpec.hs:
#   app (f (f l (b l)) (b (b l))) => (b l)
#   app (f l l) => (b l)

rel app {
    # Rule 1: app(L, z) => B(z)
    (f l $z) -> (b $z)
    |
    # Rule 2: app(B(y), z) => F(y, z)
    (f (b $y) $z) -> (f $y $z)
    |
    # Rule 3: app(F(L, y), z) => y
    (f (f l $y) $z) -> $y
    |
    # Rule 4: app(F(F(w, x), y), L) => w
    (f (f (f $w $x) $y) l) -> $w
    |
    # Rule 5: app(F(B(x), y), z) => app(app(x, z), app(y, z))
    [
        [(f (f (b $x) $y) $z) -> (f $x $z) ; app ; $x -> (f $x $y)]
        &
        [(f (f (b $x) $y) $z) -> (f $y $z) ; app ; $y -> (f $x $y)]
        ; app
    ]
    |
    # Rule 6: app(F(F(w, x), y), B(u)) => app(x, u)
    [
        (f (f (f $w $x) $y) (b $u)) -> (f $x $u)
        ; app
    ]
    |
    # Rule 7: app(F(F(w, x), y), F(u, v)) => app(app(y, u), v)
    [
        (f (f (f $w $x) $y) (f $u $v)) -> (f (f $y $u) $v)
        ;
        [(f (f $a $b) $c) -> (f $a $b) ; app ; $a -> (f $a $b)]
        &
        (f (f $a $b) $c) -> (f $d $c)
        ; app
    ]
}
